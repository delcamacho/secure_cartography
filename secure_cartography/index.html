<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#secure-cartography">Secure Cartography</a><ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#installation">Installation</a><ul>
<li><a href="#from-github">From GitHub</a></li>
</ul>
</li>
<li><a href="#usage">Usage</a></li>
<li><a href="#key-features">Key Features</a><ul>
<li><a href="#security">Security</a></li>
<li><a href="#network-discovery">Network Discovery</a></li>
<li><a href="#topology-management">Topology Management</a></li>
<li><a href="#visualization">Visualization</a></li>
<li><a href="#map-merging">Map Merging</a></li>
</ul>
</li>
<li><a href="#project-structure">Project Structure</a></li>
<li><a href="#technology-stack">Technology Stack</a><ul>
<li><a href="#core-technologies">Core Technologies</a></li>
<li><a href="#security-components">Security Components</a></li>
<li><a href="#network-interaction">Network Interaction</a></li>
<li><a href="#data-storage">Data Storage</a></li>
</ul>
</li>
<li><a href="#security-architecture">Security Architecture</a><ul>
<li><a href="#credential-protection">Credential Protection</a></li>
</ul>
</li>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#license">License</a></li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#acknowledgments">Acknowledgments</a></li>
<li><a href="#appendix-a-diagram-export-and-visualization-tools">Appendix A: Diagram Export and Visualization Tools</a><ul>
<li><a href="#exported-formats">Exported Formats</a><ul>
<li><a href="#yed-graphml-graphml">yEd GraphML (.graphml)</a></li>
<li><a href="#drawio-drawio">draw.io (.drawio)</a></li>
</ul>
</li>
<li><a href="#usage-notes">Usage Notes</a></li>
<li><a href="#recommendations">Recommendations</a></li>
</ul>
</li>
<li><a href="#appendix-b-tfsm_fire---intelligent-template-matching">Appendix B: TFSM_Fire - Intelligent Template Matching</a><ul>
<li><a href="#overview-1">Overview</a></li>
<li><a href="#key-features-1">Key Features</a><ul>
<li><a href="#1-intelligent-template-selection">1. Intelligent Template Selection</a></li>
<li><a href="#2-thread-safe-design">2. Thread-Safe Design</a></li>
<li><a href="#3-scoring-algorithm">3. Scoring Algorithm</a></li>
<li><a href="#4-template-filtering">4. Template Filtering</a></li>
</ul>
</li>
<li><a href="#use-cases">Use Cases</a></li>
<li><a href="#technical-implementation">Technical Implementation</a><ul>
<li><a href="#connection-management">Connection Management</a></li>
<li><a href="#template-parsing">Template Parsing</a></li>
</ul>
</li>
<li><a href="#advantages-over-traditional-approaches">Advantages Over Traditional Approaches</a></li>
<li><a href="#integration-example">Integration Example</a></li>
<li><a href="#future-enhancements">Future Enhancements</a></li>
</ul>
</li>
<li><a href="#dependencies-and-integrations">Dependencies and Integrations</a></li>
<li><a href="#keywords">Keywords</a></li>
</ul>
</li>
</ul>
<h1 id="secure-cartography">Secure Cartography</h1>
<p>Secure Cartography is a secure, Python-based network discovery and mapping tool designed for network engineers and IT professionals. It leverages SSH-based device interrogation to automate network discovery, visualize network topologies, and merge network maps across multi-vendor environments, including Cisco IOS, NX-OS, and Arista EOS platforms.</p>
<p><img src="screenshots/scart.png" alt="Main Application"></p>
<h2 id="overview">Overview</h2>
<p>Secure Cartography provides automated network discovery, visualization, and topology merging capabilities while maintaining strict security standards. It supports various network devices including Cisco IOS, NX-OS, and Arista EOS platforms.</p>
<p><img src="screenshots/complexmap.png" alt="Complex Network Map"></p>
<h2 id="installation">Installation</h2>
<h3 id="from-github">From GitHub</h3>
<pre><code class="lang-bash"><span class="hljs-comment"># Clone the repository</span>
git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/scottpeterman/</span>secure_cartography.git
cd secure_cartography

<span class="hljs-comment"># Create and activate virtual environment</span>
python -m venv .venv
source .venv<span class="hljs-regexp">/bin/</span>activate  <span class="hljs-comment"># On Windows: .venv\Scripts\activate</span>

<span class="hljs-comment"># Install dependencies</span>
pip install -r requirements.txt
</code></pre>
<p>PyPI package coming soon!</p>
<h2 id="usage">Usage</h2>
<p>The project includes two main executable scripts:</p>
<ol>
<li><p><strong>Network Discovery and Mapping</strong></p>
<pre><code class="lang-bash"><span class="hljs-selector-tag">python</span> <span class="hljs-selector-tag">-m</span> <span class="hljs-selector-tag">secure_cartography</span><span class="hljs-selector-class">.scart</span>
</code></pre>
</li>
<li><p><strong>Topology Merge Tool</strong></p>
<pre><code class="lang-bash"><span class="hljs-selector-tag">python</span> <span class="hljs-selector-tag">-m</span> <span class="hljs-selector-tag">secure_cartography</span><span class="hljs-selector-class">.merge_dialog</span>
</code></pre>
</li>
</ol>
<p><img src="screenshots/map_merge.png" alt="Map Merge Tool"></p>
<h2 id="key-features">Key Features</h2>
<h3 id="security">Security</h3>
<ul>
<li>Master password-based encryption system for credentials</li>
<li>Machine-specific keyring integration</li>
<li>PBKDF2-based key derivation</li>
<li>Encrypted credential storage with Fernet encryption</li>
<li>No plaintext passwords stored anywhere in the application</li>
<li>Secure session handling</li>
</ul>
<h3 id="network-discovery">Network Discovery</h3>
<ul>
<li>Multi-threaded SSH-based device discovery</li>
<li>Support for multiple authentication methods</li>
<li>Configurable discovery depth and timeout settings</li>
<li>Exclusion pattern support</li>
<li>Real-time discovery progress monitoring</li>
<li>Device platform auto-detection</li>
<li>Comprehensive logging system</li>
</ul>
<h3 id="topology-management">Topology Management</h3>
<ul>
<li>JSON-based topology storage</li>
<li>Connection de-duplication</li>
<li>Interface normalization across platforms</li>
<li>Support for CDP and LLDP</li>
<li>Automatic handling of bi-directional neighbor relationships</li>
<li>Debug information capture (optional)</li>
</ul>
<h3 id="visualization">Visualization</h3>
<ul>
<li>Dark mode optimized network diagrams</li>
<li>Multiple layout algorithms:<ul>
<li>Balloon layout for hierarchical networks</li>
<li>KK (Kamada-Kawai) for general topologies</li>
<li>Circular layout option</li>
<li>Multipartite layout support</li>
</ul>
</li>
<li>Intelligent node positioning</li>
<li>Edge label support for interface information</li>
<li>SVG output for high-quality graphics</li>
<li>Real-time preview capabilities</li>
</ul>
<h3 id="map-merging">Map Merging</h3>
<ul>
<li>Intelligent topology merging</li>
<li>Preview before merge</li>
<li>Maintains connection integrity</li>
<li>Connection de-duplication during merge</li>
<li>Comprehensive merge logging</li>
<li>Multiple file support</li>
</ul>
<h2 id="project-structure">Project Structure</h2>
<pre><code>secure_cartography/
├── README.md
├── <span class="hljs-built_in">log</span>/                    <span class="hljs-meta"># Device interrogation logs</span>
├── <span class="hljs-keyword">output</span>/                <span class="hljs-meta"># Raw discovery output</span>
├── requirements.txt       <span class="hljs-meta"># Python dependencies</span>
├── screenshots/          <span class="hljs-meta"># Documentation images</span>
├── secure_cartography/   <span class="hljs-meta"># Main package</span>
│   ├── __init__.py
│   ├── credslib.py        <span class="hljs-meta"># Credential management</span>
│   ├── diagrams.py        <span class="hljs-meta"># Visualization engine</span>
│   ├── driver_discovery.py <span class="hljs-meta"># Platform detection</span>
│   ├── enh_int_normalizer.py <span class="hljs-meta"># Interface normalization</span>
│   ├── interface_normalizer.py
│   ├── merge_dialog.py    <span class="hljs-meta"># Map merge tool</span>
│   ├── network_discovery.py <span class="hljs-meta"># Core discovery</span>
│   ├── scart.py          <span class="hljs-meta"># Main application</span>
│   ├── ssh_client_pysshpass.py <span class="hljs-meta"># SSH handling</span>
│   └── tfsm_fire.py      <span class="hljs-meta"># TextFSM template handling</span>
└── tfsm_templates.db     <span class="hljs-meta"># TextFSM parsing templates</span>
</code></pre><h2 id="technology-stack">Technology Stack</h2>
<h3 id="core-technologies">Core Technologies</h3>
<ul>
<li>Python 3.9+</li>
<li>PyQt6 for GUI</li>
<li>NetworkX for graph processing</li>
<li>Matplotlib for visualization</li>
<li>Cryptography.io for security</li>
</ul>
<h3 id="security-components">Security Components</h3>
<ul>
<li>PBKDF2 key derivation</li>
<li>Fernet encryption</li>
<li>System keyring integration</li>
<li>Platform-specific secure storage</li>
</ul>
<h3 id="network-interaction">Network Interaction</h3>
<ul>
<li>Paramiko/SSH2 for device communication</li>
<li>TextFSM for output parsing</li>
<li>Custom platform detection</li>
<li>Enhanced interface normalization</li>
</ul>
<h3 id="data-storage">Data Storage</h3>
<ul>
<li>JSON for topology data</li>
<li>YAML for configuration</li>
<li>SVG for visualizations</li>
<li>Encrypted credential storage</li>
</ul>
<h2 id="security-architecture">Security Architecture</h2>
<h3 id="credential-protection">Credential Protection</h3>
<ol>
<li><p><strong>Master Password System</strong></p>
<ul>
<li>PBKDF2-derived key generation</li>
<li>Machine-specific salt</li>
<li>Secure system keyring integration</li>
</ul>
</li>
<li><p><strong>Storage Security</strong></p>
<ul>
<li>Fernet encryption for credentials</li>
<li>No plaintext password storage</li>
<li>Platform-specific secure storage locations</li>
</ul>
</li>
<li><p><strong>Runtime Security</strong></p>
<ul>
<li>Memory-safe credential handling</li>
<li>Secure credential cleanup</li>
<li>Protected GUI input fields</li>
</ul>
</li>
</ol>
<h2 id="requirements">Requirements</h2>
<p>See <code>requirements.txt</code> for complete list of Python dependencies.</p>
<p>Core requirements:</p>
<ul>
<li>Python 3.9+</li>
<li>PyQt6</li>
<li>NetworkX</li>
<li>Matplotlib</li>
<li>Cryptography</li>
<li>PyYAML</li>
<li>Paramiko</li>
</ul>
<h2 id="license">License</h2>
<p>This project is licensed under the GNU General Public License v3.0 (GPLv3).</p>
<h2 id="contributing">Contributing</h2>
<p>Contributions are welcome! Please feel free to submit a Pull Request.</p>
<h2 id="acknowledgments">Acknowledgments</h2>
<p>[Insert Acknowledgments]</p>
<h1 id="appendix-a-diagram-export-and-visualization-tools">Appendix A: Diagram Export and Visualization Tools</h1>
<p>Secure Cartography exports network maps in multiple formats to support different visualization and analysis needs.</p>
<h2 id="exported-formats">Exported Formats</h2>
<h3 id="yed-graphml-graphml-">yEd GraphML (.graphml)</h3>
<p><img src="screenshots/yed1.png" alt="yEd Hierarchical Layout">
<img src="screenshots/yed2.png" alt="yEd Alternative Layout"></p>
<p>yEd is a powerful graph editor that excels at visualizing and analyzing complex networks. The GraphML export from Secure Cartography is specifically formatted to take advantage of yEd&#39;s advanced features:</p>
<ul>
<li>Multiple automatic layout algorithms</li>
<li>Advanced grouping capabilities</li>
<li>The &quot;Neighborhood&quot; feature in the licensed version is particularly valuable for analyzing large networks, as it can intelligently extract and visualize network segments</li>
<li>Extensive node/edge formatting options</li>
<li>High-quality vector export</li>
</ul>
<p><a href="https://www.yworks.com/products/yed">yEd Graph Editor</a> is available as both a free version and a licensed version with additional features.</p>
<h3 id="draw-io-drawio-">draw.io (.drawio)</h3>
<p><img src="screenshots/drawio.png" alt="draw.io Layout"></p>
<p>draw.io (also known as diagrams.net) provides a user-friendly interface for diagram editing and is particularly well-suited for:</p>
<ul>
<li>Collaborative diagram editing</li>
<li>Web-based access</li>
<li>Integration with various platforms</li>
<li>Custom stencils and shapes</li>
<li>Multiple export formats</li>
</ul>
<p><a href="https://www.diagrams.net/">draw.io</a> is free and open source, with desktop and web-based versions available.</p>
<h2 id="usage-notes">Usage Notes</h2>
<ol>
<li><p>Both tools offer far more layout and visualization options than shown in the default exports. Users are encouraged to experiment with different layouts to find what works best for their network topology.</p>
</li>
<li><p>For large networks:</p>
<ul>
<li>yEd&#39;s hierarchical layouts often provide the clearest visualization</li>
<li>The &quot;Neighborhood&quot; feature in yEd Pro is invaluable for focusing on specific network segments</li>
<li>draw.io&#39;s organic layouts can help visualize natural clustering in the network</li>
</ul>
</li>
<li><p>Editing Tips:</p>
<ul>
<li>Both tools maintain interface labels and node properties from Secure Cartography</li>
<li>Node positions and groupings can be manually adjusted</li>
<li>Additional network documentation can be added directly in the tools</li>
<li>Both support various export formats for documentation needs</li>
</ul>
</li>
</ol>
<h2 id="recommendations">Recommendations</h2>
<ul>
<li><p>Use yEd for:</p>
<ul>
<li>Detailed network analysis</li>
<li>Large network visualization</li>
<li>Professional documentation</li>
<li>Segment-focused analysis &quot;Neighborhoods&quot;</li>
</ul>
</li>
<li><p>Use draw.io for:</p>
<ul>
<li>Quick edits and sharing</li>
<li>Web-based collaboration</li>
<li>Platform-independent access</li>
<li>Integration with other documentation tools</li>
</ul>
</li>
</ul>
<h1 id="appendix-b-tfsm_fire-intelligent-template-matching">Appendix B: TFSM_Fire - Intelligent Template Matching</h1>
<h2 id="overview">Overview</h2>
<p>TFSM_Fire represents a novel approach to TextFSM template matching that uses an intelligent scoring system and thread-safe database operations to automatically select the best parsing template for network device output.</p>
<h2 id="key-features">Key Features</h2>
<h3 id="1-intelligent-template-selection">1. Intelligent Template Selection</h3>
<pre><code class="lang-python">def find_best_template(<span class="hljs-keyword">self</span>, device_output: <span class="hljs-keyword">str</span>, filter_string: Optional[<span class="hljs-keyword">str</span>] = <span class="hljs-literal">None</span>) -&gt; Tuple[
    Optional[<span class="hljs-keyword">str</span>], Optional[List[Dict]], <span class="hljs-keyword">float</span>]:
</code></pre>
<ul>
<li>Automatically evaluates multiple templates against device output</li>
<li>Returns the best matching template, parsed output, and confidence score</li>
<li>Uses sophisticated scoring algorithm to determine template fitness</li>
<li>Supports optional filtering to narrow template search space</li>
</ul>
<h3 id="2-thread-safe-design">2. Thread-Safe Design</h3>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafeConnection</span>:</span>
    <span class="hljs-string">"""Thread-local storage for SQLite connections"""</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, db_path: str, verbose: bool = False)</span>:</span>
        self.db_path = db_path
        self.verbose = verbose
        self._local = threading.local()
</code></pre>
<ul>
<li>Implements thread-local storage for database connections</li>
<li>Ensures safe concurrent access to template database</li>
<li>Manages connection lifecycle automatically</li>
<li>Supports high-performance parallel template matching</li>
</ul>
<h3 id="3-scoring-algorithm">3. Scoring Algorithm</h3>
<p>The template scoring system evaluates matches based on multiple factors:</p>
<ul>
<li>Number of successfully parsed records</li>
<li>Special handling for version command output</li>
<li>Intelligent weighting based on command type</li>
<li>Score normalization for consistent evaluation</li>
</ul>
<h3 id="4-template-filtering">4. Template Filtering</h3>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_filtered_templates</span><span class="hljs-params">(self, connection: sqlite3.Connection, filter_string: Optional[str] = None)</span>:</span>
    <span class="hljs-string">"""Get filtered templates from database using provided connection."""</span>
    <span class="hljs-keyword">if</span> filter_string:
        filter_terms = filter_string.replace(<span class="hljs-string">'-'</span>, <span class="hljs-string">'_'</span>).split(<span class="hljs-string">'_'</span>)
        query = <span class="hljs-string">"SELECT * FROM templates WHERE 1=1"</span>
        params = []
        <span class="hljs-keyword">for</span> term <span class="hljs-keyword">in</span> filter_terms:
            <span class="hljs-keyword">if</span> term <span class="hljs-keyword">and</span> len(term) &gt; <span class="hljs-number">2</span>:
                query += <span class="hljs-string">" AND cli_command LIKE ?"</span>
                params.append(f<span class="hljs-string">"%{term}%"</span>)
</code></pre>
<ul>
<li>Smart filtering of template database</li>
<li>Handles hyphenated command names</li>
<li>Minimum term length requirements</li>
<li>SQL injection prevention</li>
</ul>
<h2 id="use-cases">Use Cases</h2>
<ol>
<li><p><strong>Automated Template Selection</strong></p>
<ul>
<li>Network automation scripts</li>
<li>Multi-vendor environments</li>
<li>Unknown command output parsing</li>
</ul>
</li>
<li><p><strong>Parallel Processing</strong></p>
<ul>
<li>Bulk device configuration analysis</li>
<li>Large-scale network discovery</li>
<li>Real-time network monitoring</li>
</ul>
</li>
<li><p><strong>Template Development</strong></p>
<ul>
<li>Template testing and validation</li>
<li>Command output verification</li>
<li>Parser development and debugging</li>
</ul>
</li>
</ol>
<h2 id="technical-implementation">Technical Implementation</h2>
<h3 id="connection-management">Connection Management</h3>
<pre><code class="lang-python"><span class="hljs-meta">@contextmanager</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_connection</span><span class="hljs-params">(self)</span>:</span>
    <span class="hljs-string">"""Get a thread-local connection"""</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> hasattr(self._local, <span class="hljs-string">'connection'</span>):
        self._local.connection = sqlite3.connect(self.db_path)
        self._local.connection.row_factory = sqlite3.Row
</code></pre>
<ul>
<li>Context manager for automatic resource cleanup</li>
<li>Thread-local storage prevents connection conflicts</li>
<li>SQLite connection pooling for efficiency</li>
</ul>
<h3 id="template-parsing">Template Parsing</h3>
<pre><code class="lang-python"><span class="hljs-attr">textfsm_template</span> = textfsm.TextFSM(io.StringIO(template[<span class="hljs-string">'textfsm_content'</span>]))
<span class="hljs-attr">parsed</span> = textfsm_template.ParseText(device_output)
<span class="hljs-attr">parsed_dicts</span> = [dict(zip(textfsm_template.header, row)) for row in parsed]
</code></pre>
<ul>
<li>In-memory template processing</li>
<li>Structured data extraction</li>
<li>Dictionary-based output formatting</li>
</ul>
<h2 id="advantages-over-traditional-approaches">Advantages Over Traditional Approaches</h2>
<ol>
<li><p><strong>Dynamic Template Selection</strong></p>
<ul>
<li>Traditional approach requires exact template match</li>
<li>TFSM_Fire finds best match automatically</li>
<li>Handles variations in command output</li>
</ul>
</li>
<li><p><strong>Concurrent Processing</strong></p>
<ul>
<li>Traditional parsers are often single-threaded</li>
<li>TFSM_Fire supports parallel operations</li>
<li>Thread-safe database access</li>
</ul>
</li>
<li><p><strong>Maintainability</strong></p>
<ul>
<li>Centralized template database</li>
<li>Easy template updates and additions</li>
<li>Performance monitoring capabilities</li>
</ul>
</li>
</ol>
<h2 id="integration-example">Integration Example</h2>
<pre><code class="lang-python">engine = TextFSMAutoEngine(<span class="hljs-string">"./templates.db"</span>, verbose=<span class="hljs-literal">True</span>)<span class="hljs-meta">

# Process device output</span>
best_template, parsed_data, confidence = engine.find_best_template(
    device_output=<span class="hljs-string">"show version output here"</span>,
    filter_string=<span class="hljs-string">"show_version"</span>
)

<span class="hljs-keyword">if</span> confidence &gt; <span class="hljs-number">30.0</span>:<span class="hljs-meta">  # Confidence threshold</span><span class="hljs-meta">
    # Use parsed data</span>
    <span class="hljs-built_in">print</span>(f<span class="hljs-string">"Found matching template: {best_template}"</span>)
    <span class="hljs-built_in">print</span>(f<span class="hljs-string">"Parsed data: {parsed_data}"</span>)
<span class="hljs-keyword">else</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"No suitable template found"</span>)
</code></pre>
<h2 id="future-enhancements">Future Enhancements</h2>
<ol>
<li><p><strong>Machine Learning Integration</strong></p>
<ul>
<li>Template scoring based on historical success</li>
<li>Pattern recognition for new command types</li>
<li>Automated template generation</li>
</ul>
</li>
<li><p><strong>Performance Optimization</strong></p>
<ul>
<li>Template caching</li>
<li>Precompiled template patterns</li>
<li>Advanced database indexing</li>
</ul>
</li>
<li><p><strong>Template Management</strong></p>
<ul>
<li>Version control integration</li>
<li>Automated testing framework</li>
<li>Template validation tools</li>
</ul>
</li>
</ol>
<h2 id="dependencies-and-integrations">Dependencies and Integrations</h2>
<p>Secure Cartography is built on a foundation of powerful open-source libraries and tools. Each plays a critical role in enabling robust network discovery, visualization, and automation capabilities:</p>
<ul>
<li><strong><a href="https://riverbankcomputing.com/software/pyqt/intro">PyQt6</a></strong>: Provides a flexible and modern GUI framework for the application&#39;s user interface.</li>
<li><strong><a href="https://github.com/google/textfsm">TextFSM</a></strong>: Used for parsing unstructured device command outputs into structured data.</li>
<li><strong><a href="https://github.com/napalm-automation/napalm">Napalm</a></strong>: Simplifies multi-vendor network automation by providing a unified API for device interaction.</li>
<li><strong><a href="https://github.com/ktbyers/netmiko">Netmiko</a></strong>: Handles SSH communication with network devices, offering seamless execution of CLI commands.</li>
<li><strong><a href="https://github.com/paramiko/paramiko">Paramiko</a></strong>: A robust library for SSHv2 protocol implementation, used for secure device communication.</li>
<li><strong><a href="https://networkx.org/">NetworkX</a></strong>: Facilitates the graph-based representation and processing of network topology data.</li>
<li><strong><a href="https://github.com/networktocode/n2g">N2G</a></strong>: Converts topology data into visual formats, supporting tools like yEd and draw.io.</li>
</ul>
<p>Each of these libraries contributes to making Secure Cartography a feature-rich and reliable tool for network engineers.</p>
<h2 id="keywords">Keywords</h2>
<p>Python, network discovery, network automation, network topology, SSH, topology visualization, multi-vendor networks, Cisco IOS, NX-OS, Arista EOS, secure network tools.</p>

</body>
</html>